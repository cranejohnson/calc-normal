  <script type="text/javascript" src="https://code.jquery.com/jquery-latest.min.js"></script>
  <script src="https://code.highcharts.com/highcharts.js"></script>
  <script src="https://code.highcharts.com/highcharts-more.js"></script>
  <script src="https://code.highcharts.com/modules/exporting.js"></script>
  <script type="text/javascript" src="https://code.jquery.com/ui/1.11.4/jquery-ui.min.js"></script>


  <script src="https://rawgithub.com/highslide-software/draggable-points/master/draggable-points.js"></script>

  <link rel="stylesheet" href="https://code.jquery.com/ui/1.10.3/themes/smoothness/jquery-ui.css">

  <style>


    .input {
    padding:15px;
    padding-bottom:20px;
    width:200px;
    border:1px dashed gray;
    margin:5px;
    }

    .chart {
    width: 700px;
    float: left;
    height: 500px;
    margin: 0 1em 1em 0;
    }
    #leftCol {
    width: 240px;
    float:left;
    }
    #main {
    width: 960px;
    float:left;
    }

    #dataTable: {
    width:700px;
    float:left;
    }
   textarea#xsInput {
	width: 220px;
	border: 3px solid #cccccc;
	padding: 5px;
	font-family: Tahoma, sans-serif;
}

    .box-table-a{font-family:"Lucida Sans Unicode", "Lucida Grande", Sans-Serif;font-size:12px;width:230px;text-align:left;border-collapse:collapse;margin:5px;}.box-table-a th{font-size:13px;font-weight:normal;background:#b9c9fe;border-top:4px solid #aabcfe;border-bottom:1px solid #fff;color:#039;padding:8px;}.box-table-a td{background:#e8edff;border-bottom:1px solid #fff;color:#669;border-top:1px solid transparent;padding:8px;}.box-table-a tr:hover td{background:#d0dafd;color:#339;}


  </style>
<script>



Highcharts.theme = {
	colors: ['#058DC7', '#50B432', '#ED561B', '#DDDF00', '#24CBE5', '#64E572', '#FF9655', '#FFF263', '#6AF9C4'],
	chart: {
		backgroundColor: {
			linearGradient: { x1: 0, y1: 0, x2: 1, y2: 1 },
			stops: [
				[0, 'rgb(255, 255, 255)'],
				[1, 'rgb(240, 240, 255)']
			]
		},
		borderWidth: 2,
		plotBackgroundColor: 'rgba(255, 255, 255, .9)',
		plotShadow: true,
		plotBorderWidth: 1
	},
	title: {
		style: {
			color: '#000',
			font: 'bold 16px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	subtitle: {
		style: {
			color: '#666666',
			font: 'bold 12px "Trebuchet MS", Verdana, sans-serif'
		}
	},
	xAxis: {
		gridLineWidth: 1,
		lineColor: '#000',
		tickColor: '#000',
		labels: {
			style: {
				color: '#000',
				font: '11px Trebuchet MS, Verdana, sans-serif'
			}
		},
		title: {
			style: {
				color: '#333',
				fontWeight: 'bold',
				fontSize: '12px',
				fontFamily: 'Trebuchet MS, Verdana, sans-serif'

			}
		}
	},
	yAxis: {
		minorTickInterval: 'auto',
		lineColor: '#000',
		lineWidth: 1,
		tickWidth: 1,
		tickColor: '#000',
		labels: {
			style: {
				color: '#000',
				font: '11px Trebuchet MS, Verdana, sans-serif'
			}
		},
		title: {
			style: {
				color: '#333',
				fontWeight: 'bold',
				fontSize: '12px',
				fontFamily: 'Trebuchet MS, Verdana, sans-serif'
			}
		}
	},
	legend: {
		itemStyle: {
			font: '9pt Trebuchet MS, Verdana, sans-serif',
			color: 'black'

		},
		itemHoverStyle: {
			color: '#039'
		},
		itemHiddenStyle: {
			color: 'gray'
		}
	},
	labels: {
		style: {
			color: '#99b'
		}
	},

	navigation: {
		buttonOptions: {
			theme: {
				stroke: '#CCCCCC'
			}
		}
	}
};

// Apply the theme
var highchartsOptions = Highcharts.setOptions(Highcharts.theme);

var defaultData = [
        {x:0,y:28.77},
        {x:6.7,y:28.61},
        {x:13.47,y:25.25},
        {x:21.95,y:23.9},
        {x:31.19,y:23.69},
        {x:31.74,y:23.59},
        {x:42.2,y:19.54},
        {x:58.04,y:18.04},
        {x:86,y:17.45},
        {x:115.7,y:17.67},
        {x:139.77,y:16.98},
        {x:169.64,y:16.76},
        {x:187.41,y:14.62},
        {x:188.56,y:11.85},
        {x:199.34,y:10.7},
        {x:206.49,y:9.79},
        {x:219.48,y:8.49},
        {x:229.36,y:7.65},
        {x:239.39,y:7.44},
        {x:254.45,y:7.33},
        {x:269.64,y:8.15},
        {x:283.8,y:7.7},
        {x:300.43,y:6.46},
        {x:311.14,y:6.04},
        {x:320.12,y:7.92},
        {x:330.35,y:8.88},
        {x:339.18,y:8.77},
        {x:350.08,y:8.1},
        {x:359.61,y:8.29},
        {x:365.68,y:9.72},
        {x:370.56,y:14.04},
        {x:379.36,y:16.27},
        {x:384.52,y:25.42},
        {x:405.55,y:27.73}
    ];

var  normalDepth = {
    lengthUnits : 'ft',
    wse : 8,
    depth : 4,
    flowArea: 0,
    XSData : [
        {x:0,y:28.77},
        {x:6.7,y:28.61},
        {x:13.47,y:25.25},
        {x:21.95,y:23.9},
        {x:31.19,y:23.69},
        {x:31.74,y:23.59},
        {x:42.2,y:19.54},
        {x:58.04,y:18.04},
        {x:86,y:17.45},
        {x:115.7,y:17.67},
        {x:139.77,y:16.98},
        {x:169.64,y:16.76},
        {x:187.41,y:14.62},
        {x:188.56,y:11.85},
        {x:199.34,y:10.7},
        {x:206.49,y:9.79},
        {x:219.48,y:8.49},
        {x:229.36,y:7.65},
        {x:239.39,y:7.44},
        {x:254.45,y:7.33},
        {x:269.64,y:8.15},
        {x:283.8,y:7.7},
        {x:300.43,y:6.46},
        {x:311.14,y:6.04},
        {x:320.12,y:7.92},
        {x:330.35,y:8.88},
        {x:339.18,y:8.77},
        {x:350.08,y:8.1},
        {x:359.61,y:8.29},
        {x:365.68,y:9.72},
        {x:370.56,y:14.04},
        {x:379.36,y:16.27},
        {x:384.52,y:25.42},
        {x:405.55,y:27.73}
    ],
    n: 0.035,
    slope : 0.002,
    q : 20000
    }



$(function() {

   $( "#nslider" ).slider({
      min: 0.005,
      max: 0.15,
      step: 0.001,
      value: normalDepth.n,
      slide: function( event, ui ) {
          $( "#n" ).val( ui.value );
        normalDepth.n = $("#n").val();
      	updateChart();
      },
    stop: function( event, ui ) {
        normalDepth.n = $("#n").val();
      	updateChart();
      }
    });
    $( "#n" ).val( $( "#nslider" ).slider( "value" ) );

   $( "#sslider" ).slider({
      min: 0.00001,
      max: 0.02,
      step: 0.0001,
      value: normalDepth.slope,
      slide: function( event, ui ) {
          $( "#slope" ).val( ui.value );
        normalDepth.slope = $("#slope").val();
      	updateChart();
      },
    stop: function( event, ui ) {
        normalDepth.slope = $("#slope").val();
      	updateChart();
      }
    });

  $( "#slope" ).val( $( "#sslider" ).slider( "value" ) );

  $( "#qslider" ).slider({
      min: 100,
      max: 40000,
      step: 100,
      value: normalDepth.q,
      slide: function( event, ui ) {
          $( "#q" ).val( ui.value );
        normalDepth.q = parseFloat($("#q").val());
      	updateChart();
      },
    stop: function( event, ui ) {
        normalDepth.q = parseFloat($("#q").val());
      	updateChart();
      }
    });

    $( "#q" ).val( $( "#qslider" ).slider( "value" ) );

  $( "#wseslider" ).slider({
      min: 0,
      max: 35,
      step: 0.1,
      value: normalDepth.wse,
      slide: function( event, ui ) {
          $( "#wse" ).val( ui.value );
        normalDepth.wse = parseFloat($("#wse").val());
      	updateChart();
      },
    stop: function( event, ui ) {
        normalDepth.wse = parseFloat($("#wse").val());
      	updateChart();
      }
    });

    $( "#wse" ).val( $( "#wseslider" ).slider( "value" ) );

    $("#n").change(function() {
    normalDepth.n = parseFloat($("#n").val());
    updateChart();
  });

  $("#slope").change(function() {
    normalDepth.slope = parseFloat($("#slope").val());
    updateChart();
  });

  $("#q").change(function(){
    normalDepth.q = parseFloat($("#q").val());
    updateChart();
  });

  $("#wse").change(function(){
    normalDepth.wse = parseFloat($("#wse").val());
    updateChart();
  });

  });
  </script>



    <h3>Normal Depth Demonstration Tool</h3>
    <div id='main'>
One the most commonly used equations governing Open Channel Flow is known as the Mannings's Equation. It was introduced by the Irish Engineer Robert Manning in 1889 as an alternative to the Chezy Equation. The Mannings equation is an empirical equation that applies to uniform flow in open channels and is a function of the channel velocity, flow area and channel slope.
<br>
<img style="display: block; margin: 0 auto;" src="Eq_Manning.gif">
<br>
Where:<br>
          Q = Flow Rate, (ft<sup>3</sup>/s)<br>
          v = Velocity, (ft/s)<br>
          A = Flow Area, (ft<sup>2</sup>)<br>
          n = Manning's Roughness Coefficient<br>
          R = Hydraulic Radius, (ft)<br>
          S = Channel Slope, (ft/ft)<br><br>

Under the assumption of uniform flow conditions the bottom slope is the same as  the slope of the energy grade line and the water surface slope. The Manning’s n is a coefficient which represents the roughness or friction applied to the flow by the channel.   Manning’s n-values are often selected from tables, but can be back calculated from field measurements. In many flow conditions the selection of a Manning’s roughness coefficient can greatly affect computational results.<hr>
<p><strong>Instructions:</strong> Select variable to solve, adjust slider bars, click on graph to modify the cross section. CSV cross section data can be loaded in the input box below. This online calculator is for demonstration and educational purposes only.</p>
    <div id='leftCol'>
      <div class = 'input'>Solve For:
        <select id = "solvetype">
          <option value="s">Slope</option>
          <option value="w" selected >Water Surface (normal depth)</option>
          <option value="n">Manning's n value</option>
          <option value="q">Discharge</option>
        </select>
      </div>
      <div class = 'input'>Slope:<input type="text" id="slope" size = "5" value = "0.001"> (<span class="lengthUnits"></span>/<span class="lengthUnits"></span>)<br><br><div id="sslider"></div></div>
      <div class = 'input'>WSE:<input type="text" id="wse" size = "5" value = ""> (<span class="lengthUnits"></span>)<br><br><div id='wseslider'></div></div>
      <div class = 'input'>Channel Manning n:<input type="text" id="n" size = "5" value="0.035"><br><br><div id="nslider"></div></div>
      <div class = 'input'>Flow:<input type="text" id="q" size = "10" value="400"> (<span class="lengthUnits"></span><sup>3</sup>/s)<br><br><div id='qslider'></div>
      <input type="text" id="minQ" size = "6" value="100" style="float:left;border: none;border-color: transparent;">
      <input type="text" id="maxQ" size = "10" value="40000" style="text-align:right;float:right;border: none;border-color: transparent;"></div>
<!--      <input type="radio" name="units" value="m" checked onclick="setUnits();calcPage();"> Meters<br>-->
      <input type="button" value="Reset Cross Section" onClick="resetXS('section'); updateChart();">

      <table class='box-table-a'>
	    <tr><td>Flow Area:</td><td> <span id='area'></span></td><tr>
      	<tr><td>Wetted Perimeter:</td><td> <span id='wetP'></span></td><tr>
      	<tr><td>Max Depth:</td><td> <span id='depth'></span> (<span class="lengthUnits"></span>)</td><tr>
      	<tr><td>Average Velocity:</td><td> <span id='avgVel'></span> (<span class="lengthUnits"></span>/s)</td><tr>
      	<tr><td>Top Width:</td><td> <span id='topWidth'></span> (<span class="lengthUnits"></span>)</td><tr>
      	<tr><td>Iterations:</td><td> <span id='iterations'></span></td><tr>
      	<tr><td>Froude Number:</td><td> <span id='froude'></span></td><tr>
      </table>
      <br><br>
       <div id='dataTable'>Load CSV XS Data Below (station,elevation)<br>

       <button onclick="    updatePlotData('section',0,'xsInput'); updateChart();">Update Plot</button><br>
       <textarea id='xsInput' placeholder="Cross Section Data Goes Here."></textarea></div>
    </div>
      <div id='section' class='chart'></div>
        Select HECRAS Geometry:<input type="file" id="fileinput" /> <input type='button' id='btnLoad' value='Load HEC-RAS Data' onclick='console.log(handleFileSelect());'></br></br></br>
        <select id='options' style="display:none"></select><br><br>
    </div>



<script>


$('#options').on('change', function() {

    var chart= $('#section').highcharts();
    chart.get('ground').setData(JSON.parse(this.value));
    chart.get('originalGround').setData(JSON.parse(this.value));
    updateChart();
});

$('#minQ').on('change', function() {
    $("#qslider" ).slider( "option", "min", parseInt(this.value) );
});


$('#maxQ').on('change', function() {
    $("#qslider" ).slider( "option", "max", parseInt(this.value) );
});


$('#section').highcharts({
    wse:normalDepth.wse,
    q:normalDepth.q,
    n:normalDepth.n,
    slope:normalDepth.slope,
    credits: false,
    tooltip: {
        pointFormat: "Elevation: {point.y:.2f} ft",
        shared: true,
        positioner: function () {
            return { x: 80, y: 50 };
        }
    },
    plotOptions: {
        series: {
            stickyTracking: false,
            threshold: null,

        }
    },

    chart: {
        ignoreHiddenSeries : false,
        zoomType: 'xy',
        events: {
            click: function(e) {
                console.log('clicked');
                // find the clicked values and the series
                var x = e.xAxis[0].value;
                newY = Math.round(e.yAxis[0].value/0.1)*0.1;
                series = this.get('ground');
                var closest = -1;
                var i = 0;
                var dist = 99999;
                $.each(series.data, function(){
                    if(Math.abs(this.x-x)<dist){
                        dist = Math.abs(this.x-x);
                        closest = i;
                    }
                    i++;
                });
                series.data[closest].update(y = newY);
                updateChart();
            }
        }
    },
    series:
    [{
        data: normalDepth.XSData,
        type : 'area',
        name : 'Ground',
        draggableY: true,
        dragPrecisionY: 0.01,
        enableMouseTracking: false,
        zIndex : 10,
        id:'ground',
        animation : false,
        color : 'brown',
        fillOpacity: 1,
        marker : {
            fillColor: '#FFFFFF',
            enabled : true,
            radius: 3,
            lineColor: 'brown',
            lineWidth:1
        },
        point:{
            events:{
                drop:function() {
                    console.log('dropped');
                    updateChart()
                }
            }
        }
    },
    {
      data: wsePlotData(normalDepth.XSData,normalDepth.wse),
      type : 'area',
      name : 'Water',
      animation : false,
      tooltip: { enabled: false},
      id:'water',
      zIndex: 1,
      color : 'rgb(0,0,204)',
      fillOpacity: 0.5,
      marker : { enabled : false},
      enableMouseTracking: false,
      states: {
        hover: {
         enabled: false
        }
      }
    },
    {
      data: normalDepth.XSData,
      name : 'Original XS',
      type : 'line',
      zIndex : 20,
      animation : false,
      color : 'white',
      showInLegend: false,
      id:'originalGround',
      lineWidth: 1,
      dashStyle: 'longdash',
      enableMouseTracking: false,
      states: {
        hover: {
         enabled: false
        }
      },
      marker : {
      	enabled : false
        },
    }
    ],
  yAxis: {
    title: {
      enabled : true,
      text : 'Elevation ('+normalDepth.lengthUnits+')',
      style: {
        fontSize : '16px'
      }
    }
  },
  xAxis: {
    title: {
      enabled : true,
      text : 'Station ('+normalDepth.lengthUnits+')',
      style: {
        fontSize : '16px'
      }
    }
  },
  title: {
    text: 'Channel Cross Section'
  }
});

updateChart();





///////////////////////////////////
//  Update XS Data
///////////////////////////////////

function handleFileSelect()
  {
    var hecrasData = [];
    if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
      alert('The File APIs are not fully supported in this browser.');
      return;
    }

    input = document.getElementById('fileinput');
    if (!input) {
      alert("Um, couldn't find the fileinput element.");
    }
    else if (!input.files) {
      alert("This browser doesn't seem to support the `files` property of file inputs.");
    }
    else if (!input.files[0]) {
      alert("Please select a file before clicking 'Load'");
    }
    else {
        file = input.files[0];
        var reader = new FileReader();
        reader.readAsText(file);
        reader.onloadend=function(){
            text = $.trim(reader.result);
            var splitStr = /Type RM Length L Ch R =/;
            var Xsections = text.split(splitStr);
            $.each(Xsections,function(){
                var section = {};
                someText = this.replace(/(\r\n|\n|\r)/gm,"");
                var re = /BEGIN DESCRIPTION:(.+)END DESCRIPTION:/m;
                var arr = re.exec(someText);
                if(arr == null) {return;}
                section.title = arr[1];
                var xsre = /#Sta\/Elev=\s+(\d+)(.+)#Mann/gmi;
                arr = xsre.exec(someText);
                if(arr == null) {return;}
                section.xsNum = arr[1];
                xsData = $.trim(arr[2]);
                var data =  xsData.match(/\S+/g);
                var plotData = [];
                var i = 'x';
                var num = 0;
                $.each(data,function(){
                    if(i == 'x'){
                        plotData[num] = {};
                        plotData[num].x = parseFloat(this);
                        i = 'y';
                    }else{
                        plotData[num].y = parseFloat(this);
                        i = 'x';
                        num = num + 1;
                    }
                });
                section.xsData = plotData;
                console.log(section);
                hecrasData.push(section);
                console.log('pushed');

            });
             console.log(hecrasData);
             var options = $("#options");
             options.show();
             $.each(hecrasData,function(){
                    options.append($("<option />").val(JSON.stringify(this.xsData)).text(this.title+'('+this.xsNum+')'));
             });
                var chart= $('#section').highcharts();
                chart.get('ground').setData(hecrasData[0].xsData);
                chart.get('originalGround').setData(hecrasData[0].xsData);
                updateXSdata('section',0,'xsInput');
                updateChart();
        }

    }


  }

function receivedText() {
    document.getElementById('editor').appendChild(document.createTextNode(fr.result));
  }

function updatePlotData(chartId,series,textId){
    var text = $.trim($("#"+textId).val());

    text = text.replace(/\r?\n/g, ',').replace(/\t/g,',');
    var data = text.split(/[ ,]+/);
    var x = true;
    var plotData = [];
    var num = 0;
    $.each(data,function(){

        if(x){
            plotData[num] = {};
            plotData[num].x = parseFloat(this);
        }
        if(!x) {
            plotData[num].y = parseFloat(this);
            num = num + 1;
        }
        x = !x;

    });
    var chart= $('#'+chartId).highcharts();
    chart.get('ground').setData(plotData);
    chart.get('originalGround').setData(plotData);

}

function resetXS(chartId){
    var chart= $('#'+chartId).highcharts();
    var plotData = [];
    var num = 0;
    $.each(chart.get('originalGround').data,function(){
        plotData[num] = {};
        plotData[num].x = parseFloat(this.x);
        plotData[num].y = parseFloat(this.y);
        num = num + 1;
    });
    chart.get('ground').setData(plotData);
    //chart.get('originalGround').setData(chart.get('originalGround').data);

}


///////////////////////////////////
//  Update Text Area Data
///////////////////////////////////

function updateXSdata(chartId,series,textId){
    var newData = new Array();
    var chart= $('#'+chartId).highcharts();
    var textData = '';
    var h = 0;
    series = chart.series[series].data;
    $.each(series, function(){
        textData = textData + this.x.toFixed(2) + ','+this.y.toFixed(2)+'\n';
        h = h+1;
  });
  $("#"+textId).val(textData);
  $("#"+textId).attr('rows', h);
}




///////////////////////////////////
//  Linear Interpolation
///////////////////////////////////

function lineInterpolate( point1, point2,XorY,value){
  var result = new Object();
  if(XorY == 'x'){
  result.y = value;
  ratio = (value-point1.y)/(point2.y-point1.y);
  result.x = Math.round(point1.x+ratio*(point2.x-point1.x));
  }
  if(XorY == 'y'){
  result.x = value;
  ratio = (value-point1.x)/(point2.x-point1.x);
  result.y = Math.round(point1.y+ratio*(point2.y-point1.y));
  }
  return result;
}

///////////////////////////////////
//  Array Lookup
///////////////////////////////////

function arrayLookup(XorY,value,array){
  var point = new Array();
  for (i = 0; i < array.length-1; i++){
    if(XorY == 'y'){
      if(array[i+1][1] <= value) {
        point = lineInterpolate(array[i],array[i+1],'y',value);
        break;
      }
    }
    if(XorY == 'x'){
      if(array[i+1][0] >= value){
        point = lineInterpolate(array[i],array[i+1],'x',value);
        break;
      }
    }
  }
  return point;
}




///////////////////////////////////
//  Develops the water surface plot data
///////////////////////////////////


function wsePlotData(XSdata,wse){
  var minX = 9999;
  var maxX = -9999;
  var data = new Array();
  for(i=1;i<=XSdata.length;i++){
    if(XSdata[i-1].x<minX) minX = XSdata[i-1].x;
    if(XSdata[i-1].x>maxX) maxX = XSdata[i-1].x;
    }
  data = [{
      x: minX,
      y:wse},
      {
      x:maxX,
      y:wse}];

  return data;
  }

///////////////////////////////////
//  Calculate area under the curve
///////////////////////////////////

function areaUnderCurve(XSdata){
  var area = 0;
  for(i=0;i<XSdata.length-1;i++){
    area += ((XSdata[i].y+XSdata[i+1].y)/2)*(XSdata[i+1].x-XSdata[i].x);
    }
  return area;

  }

///////////////////////////////////
//  Calculate Froude Number
///////////////////////////////////

function calcFroude(avgVel,avgDepth){
    g=32;
    froude = 0;
    froude = avgVel/(Math.sqrt(g*avgDepth));
  return froude;

  }


///////////////////////////////////
//  Calculate top width
///////////////////////////////////

 function calcWidth(series,wse){
  var trimmed = trimGround(series,wse);
  var width = 0;
  for(i=0;i<trimmed.length-1;i++){
    if(trimmed[i].y<wse || trimmed[i+1].y<wse){
      width += (trimmed[i+1].x-trimmed[i].x);
    }
  }
  return width;
}
///////////////////////////////////
//  Trim ground to max wse, return data
///////////////////////////////////

function trimGround(series,wse){
  var trimmed = Array();
  var yVal;
  for(i=0;i<series.length-1;i++){
    yVal = series[i].y;
    if(series[i].y>wse) yVal = wse;
    trimmed.push({
          x:series[i].x,
          y: yVal}
          );
    if((series[i].y>wse) && (series[i+1].y<wse)){
      point = lineInterpolate(series[i],series[i+1],'x',wse);
      trimmed.push(point);
      }
    if ((series[i].y<wse) && (series[i+1].y>wse)){
      point = lineInterpolate(series[i],series[i+1],'x',wse);
      trimmed.push(point);
      }

  }
  yVal = series[series.length-1].y;
  if(series[series.length-1].y>wse) yVal = wse;
  trimmed.push({
        x:series[series.length-1].x,
        y: yVal}
        );
  return trimmed;
}



///////////////////////////////////
//  Solve Mannings Equation
//      Q = (k/n) AR2/3S1/2
///////////////////////////////////

function mannings(slope,nValue,discharge,wse,xsData,solveFor){
  console.log('solving for:'+solveFor);
  var k = 1.486;

  if(solveFor == 'q'){
    var wetP = wettedP(xsData,wse);
    var area =   areaUnderCurve(wsePlotData(xsData,wse))-areaUnderCurve(trimGround(xsData,wse));
    discharge = (k/nValue)*(area)*Math.pow(area/wetP,.666666)*Math.pow(slope,.5);
    return discharge;

  }
  if(solveFor == 's'){
    var wetP = wettedP(xsData,wse);
    var area =   areaUnderCurve(wsePlotData(xsData,wse))-areaUnderCurve(trimGround(xsData,wse));
    slope = Math.pow(discharge/((k/nValue)*(area)*Math.pow(area/wetP,.666666)),2);
    return slope;

  }
  if(solveFor == 'n'){
    var wetP = wettedP(xsData,wse);
    var area =   areaUnderCurve(wsePlotData(xsData,wse))-areaUnderCurve(trimGround(xsData,wse));
    nValue = ((k)*(area)*Math.pow(area/wetP,.666666)*Math.pow(slope,.5))/discharge;
    return nValue;
  }

  if(solveFor == 'wse'){
    var iterate = true;
    var i = 0;
    var minGround = 9999;
    for(i=0;i<xsData.length-1;i++){
        if(xsData[i].y<minGround) minGround = xsData[i].y;
    }

    if(wse < minGround){
          wse = minGround +5;
         console.log('New estimate for wse: '+wse);

    }
    while(iterate){
      var wetP = wettedP(xsData,wse);
      var area = areaUnderCurve(wsePlotData(xsData,wse))-areaUnderCurve(trimGround(xsData,wse));
      var newDischarge = (k/nValue)*(area)*Math.pow(area/wetP,.666666)*Math.pow(slope,.5);
      var diff = Math.abs(newDischarge -  discharge);
      //if (diff > oldDiff) iterate = false;
      if(diff > discharge*.003){
        iterate = true;
      }
      else{
        iterate = false;
      }

      if(newDischarge > discharge){
        direction = -1;
       }
      else{
        direction = 1;
      }

      wse = wse + (direction*0.005);
      i++;
      if(i > 5000 || diff < (discharge*.0001)) iterate = false;
      var oldDiff = diff;

    }
    if(i > 50000){
		$("#iterations").html('max');
	}
	else{
	 	$("#iterations").html(i);
	}
    return wse;
  }
}

function calcWSE(series,depth){
  var min = 9999;
  var minpt = 0;
  for(i=0;i<series.length;i++){
    if(series[i].y<min) min = series[i].y;
    }

  return min+depth;
}

function calcDepth(series,wse){
  var min = 9999;
  var minpt = 0;
  for(i=0;i<series.length;i++){
    if(series[i].y<min) min = series[i].y;
    }
  return (wse-min);
}

function wettedP(series,wse){
  var trimmed = trimGround(series,wse);
  var wetP = 0;
  for(i=0;i<trimmed.length-1;i++){
    if(trimmed[i].y<wse || trimmed[i+1].y<wse){
      wetP += Math.sqrt(Math.pow((trimmed[i+1].x-trimmed[i].x),2)+Math.pow((Math.abs(trimmed[i].y-trimmed[i+1].y)),2));
    }
  }
  return wetP;
}

function calcVel(Q,A){
  return Q/A;
}





function solver(chartId){
  var chart= $('#'+chartId).highcharts();
  XSData = chart.get('ground').data;
  if($("#solvetype").val() == 'q')
    normalDepth.q = mannings(normalDepth.slope,normalDepth.n,normalDepth.q,normalDepth.wse,XSData,'q');
  if($("#solvetype").val() == 'w')
    normalDepth.wse = mannings(normalDepth.slope,normalDepth.n,normalDepth.q,normalDepth.wse,XSData,'wse');
  if($("#solvetype").val() == 'n')
    normalDepth.n = mannings(normalDepth.slope,normalDepth.n,normalDepth.q,normalDepth.wse,XSData,'n');
  if($("#solvetype").val() == 's')
    normalDepth.slope = mannings(normalDepth.slope,normalDepth.n,normalDepth.q,normalDepth.wse,XSData,'s');

  normalDepth.flowArea = areaUnderCurve(wsePlotData(XSData,normalDepth.wse))-areaUnderCurve(trimGround(XSData,normalDepth.wse));
  if(normalDepth.flowArea < 0 ) normalDepth.flowArea = 0;
  normalDepth.wetP = wettedP(XSData,normalDepth.wse);

  normalDepth.topWidth = calcWidth(XSData,normalDepth.wse);

  normalDepth.avgVel = calcVel(normalDepth.q,normalDepth.flowArea).toFixed(2);
  normalDepth.froude = calcFroude(normalDepth.avgVel,(normalDepth.flowArea/normalDepth.topWidth));
 }



function updateChart(){
    updateXSdata('section',0,'xsInput');
    solver('section');
    var chart= $('#section').highcharts();
    chart.get('water').setData(wsePlotData(chart.get('ground').data,normalDepth.wse));
    var yDataMin = chart.yAxis[0].getExtremes().dataMin;
    chart.yAxis[0].setExtremes(yDataMin-5,null);
    loadFields();


}

function loadFields(){
  var chart= $('#section').highcharts();
  $("#avgVel").html(normalDepth.avgVel);
  $(".lengthUnits").html(normalDepth.lengthUnits);
  $("#wetP").html(normalDepth.wetP.toFixed(1)+" ("+normalDepth.lengthUnits+")");
  $("#q").val(normalDepth.q.toFixed(0));
  $("#n").val(parseFloat(normalDepth.n).toFixed(3));
  $("#nslider").slider({value : $("#n").val()});
  $("#qslider").slider({value:$("#q").val()});
  $("#wseslider").slider({value:$("#wse").val()});
  $("#wseslider").slider({ min: chart.yAxis[0].getExtremes().dataMin});
  $("#wseslider").slider({ max: chart.yAxis[0].max});
  //console.log("minq: "+$("#qslider").slider("option","min"));

  $("#slope").val(normalDepth.slope);
  $("#froude").html(normalDepth.froude.toFixed(2));
  $("#topWidth").html(normalDepth.topWidth);
  $("#sslider").slider({value : $("#slope").val()});
  $("#area").html(normalDepth.flowArea.toFixed(1)+" ("+normalDepth.lengthUnits+"<sup>2</sup>)");
  $("#wse").val(normalDepth.wse.toFixed(2));
  $("#depth").html(calcDepth(normalDepth.XSData,normalDepth.wse).toFixed(2));
}







  </script>
